<!DOCTYPE html>
<html class="no-js" lang="en-GB">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="theme-color" content="#1b1b1b">
	<title>Pipe Sink | Peter&#39;s Notebook</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Pipe Sink" />
<meta property="og:description" content="I had an idea/desire for a &ldquo;simple&rdquo; template class that&rsquo;d work as my OpenGL thread. A contemporary design for multi-threaded 3D games10 seems to be pooling work and processing it in whatever threads are available. IME OpenGL/GLFW are not re-entrant; Apple2 and GLFW3 explicitly states that it won&rsquo;t work - so it seems safe to assume that I shouldn&rsquo;t call functions from different threads. So to make a super-fast 3D game (or whatever) I need to do less work on the thread which is running OpenGL while allowing other threads to send it whatever work they please." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://peterlavalle.github.io/post/pal-pipe-sink/" />
<meta property="article:published_time" content="2017-08-03T00:00:00&#43;00:00"/>
<meta property="article:modified_time" content="2017-08-03T00:00:00&#43;00:00"/>

	<link rel="stylesheet" href="/css/bundle.css">
	<link rel="icon" href="/icons/16.png" sizes="16x16" type="image/png">
	<link rel="icon" href="/icons/32.png" sizes="32x32" type="image/png">
		
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'G-HXL9LMR22V', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

	<script data-ad-client="ca-pub-8101356904122802" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
</head>
<body>
	<header class="header">
	<script type='text/javascript'>
		
		if ('peterlavalle.com' == window.location.hostname)
			location.replace('https://peterlavalle.github.io' + window.location.pathname);
	</script>
	<a class="logo" href="/">Peter&#39;s Notebook</a>
	
<nav class="main-nav" role="navigation">
	<button id="toggle" class="main-nav__btn" aria-label="Menu toggle" aria-expanded="false" tabindex="0">
		<div class="main-nav__btn-box" tabindex="-1">
			<svg class="main-nav__icon icon-menu" width="18" height="18" viewBox="0 0 18 18">
				<path class="icon-menu__burger" d="M18 0v3.6H0V0h18zM0 10.8h18V7.2H0v3.6zM0 18h18v-3.6H0V18z"/>
				<path class="icon-menu__x" d="M11.55 9L18 15.45 15.45 18 9 11.55 2.55 18 0 15.45 6.45 9 0 2.55 2.55 0 9 6.45 15.45 0 18 2.55 11.55 9z"/>
			</svg>
		</div>
	</button>
	<ul id="menu" class="main-nav__list">
			<li class="main-nav__item">
				<a class="main-nav__link" href="/hobby/">
					
					<span class="main-nav__text">Hobby</span>
					
				</a>
			</li>
			<li class="main-nav__item">
				<a class="main-nav__link" href="/tags/howto/">
					
					<span class="main-nav__text">How To</span>
					
				</a>
			</li>
			<li class="main-nav__item">
				<a class="main-nav__link" href="/tools/">
					
					<span class="main-nav__text">Tools</span>
					
				</a>
			</li>
			<li class="main-nav__item">
				<a class="main-nav__link" href="/work-and-contibutions/">
					
					<span class="main-nav__text">Work</span>
					
				</a>
			</li>
	</ul>
</nav>
</header>
	<div class="primary">
	
	<main class="main">
		
		<div class="single block">
			<article class="entry">
	<div class="entry__meta meta mb">
	<time class="entry__meta-published meta-published" datetime="2017-08-03T00:00:00Z">August 03, 2017</time>
	</div>
				<h1 class="entry__title">Pipe Sink</h1>
				<div class="entry__content">

<p>I had an idea/desire for a &ldquo;simple&rdquo; template class that&rsquo;d work as my OpenGL thread.
A contemporary design for multi-threaded 3D games<sup class="footnote-ref" id="fnref:4aEngine"><a href="#fn:4aEngine">1</a></sup><sup class="footnote-ref" id="fnref:or-whatever"><a href="#fn:or-whatever">0</a></sup> seems to be pooling work and processing it in whatever threads are available.
IME OpenGL/GLFW are not re-entrant; Apple<sup class="footnote-ref" id="fnref:AppleOpenGLThreads"><a href="#fn:AppleOpenGLThreads">2</a></sup> and GLFW<sup class="footnote-ref" id="fnref:GLFWReentrancy"><a href="#fn:GLFWReentrancy">3</a></sup> explicitly states that it won&rsquo;t work - so it seems safe to assume that I shouldn&rsquo;t call functions from different threads.
So to make a super-fast 3D game (or whatever) I need to do less work on the thread which is running OpenGL while allowing other threads to send it whatever work they please.</p>

<p>My requirements are;</p>

<ul>
<li>Separate <strong>handler-thread</strong> for just OpenGL rendering</li>
<li>Other threads need to be able to submit &ldquo;messages&rdquo; to the handler-thread

<ul>
<li>a thread&rsquo;s messages must/should be received FIFO by the handler-thread</li>
<li>I don&rsquo;t need any guarantee of ordering between threads</li>
</ul></li>
<li>As always, I want to minimise <em>dynamic invocations</em> and allocations

<ul>
<li>only a single <code>virtual</code> invocation is used per message</li>
<li>all allocation is done in-place</li>
</ul></li>
<li>I&rsquo;m perfectly happy for the handler-thread to create and destroy the GLFW window and OpenGL context

<ul>
<li>a <code>HANDLER</code> instance is used to contain logic for this thing</li>
</ul></li>
</ul>

<p>This feels like a threading primitive that I have seen nothing which feels this nimble before.
So here goes my blog post on the subject; I&rsquo;m sure that someone else has done something more sophisticated, however, my fascination with minimalism justifies the time that I spent on this implementation and write-up.</p>

<p><strong><code>2017-08-04</code></strong> ; I ran a grammar check and reworked this article to use GoogleTest.</p>

<h2 id="class-declarations">Class Declarations</h2>

<p>The solution presented here is composed of two class templates a single global function, and one <code>typedef</code> for the index type.
The <code>typedef</code> is a bit of a flourish, and the global function is my &ldquo;sleepy wait&rdquo; method.
The classes <code>pipe</code> and <code>sink</code> were originally &ldquo;uncoupled&rdquo; and <code>pipe</code> didn&rsquo;t need the <code>HANDLER</code> type-name.
In the future - I&rsquo;d like to reintroduce that abstraction, for the time being - this is &ldquo;good enough&rdquo; to proceed.</p>

<p>The <code>pipe</code> class contains the buffer that the messages are put into, along with the necessary counters of type <code>pipe_sink_index_t</code> to track usage.
The actual <code>pipe</code> itself is a logical interface, and only exposes the <code>send()</code> method to client code.
The storage and processing mechanisms for messages are hidden from the <code>MESSAGE</code> and <code>HANDLER</code> classes.
Vardric template parameters and r-value references are used to ameliorate the invocation overhead.
This leads to an elaborate <code>send()</code> method which is detailed separately below.</p>

<p>The <code>sink</code> class is the &ldquo;entry point&rdquo; and creates the <code>pipe</code> for messages and an instance of <code>std::thread</code> to process the messages.
The instance of the <code>HANDLER</code> template parameter is created inside of the thread to provide the &ldquo;meat&rdquo; of processing messages.
In my design - the <code>HANDLER</code> creates and destroys the GLFW window as well as initialising GL function pointers.
Vardric template parameters are again used in an attempt to minimise the cost of these methods, however, I&rsquo;ve not yet found a way to <em>move</em> the parameters into the thread&rsquo;s lambda.
This is all done on the handler-thread, making the <code>sink</code> constructor and destructor complex enough to (also) warrant a separate discussion.</p>

<p>Two further methods are available to ease the use - in both cases these fall under the <a href="https://git-scm.com/book/en/v2/Git-Internals-Plumbing-and-Porcelain">&ldquo;porcalin&rdquo; rather than &ldquo;plumbing&rdquo; taxonomy</a>.
On occaision (such as durring an automated test) a thread will wish to wait for a pipe to empty - the <code>pipe::join()</code> method accompolishes this.
Rarely, it may be convient to access the <code>HANDLER</code> instance from another thread - to support this the <code>sink::-&gt;</code> operator is overloaded to return a pointer.
These functios could be provided by client code - so the rest of this document effectively ignores them.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">#pragma once
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// V$2013 doesn&#39;t have `noexcept` so this works around that
</span><span style="color:#75715e">// ... and I expect other things will be missing too
</span><span style="color:#75715e"></span><span style="color:#75715e">#if !defined(_MSC_VER ) || (_MSC_VER &gt;= 1900)
</span><span style="color:#75715e">#    ifndef pal_noexcept
</span><span style="color:#75715e">#        define pal_noexcept noexcept
</span><span style="color:#75715e">#    endif
</span><span style="color:#75715e">#else
</span><span style="color:#75715e">#    ifndef pal_noexcept
</span><span style="color:#75715e">#        define pal_noexcept
</span><span style="color:#75715e">#    endif
</span><span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;thread&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mutex&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdint.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">namespace</span> pal
{
	<span style="color:#75715e">/// stupid, icky, easy, safe
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">void</span> pipe_sink_sleep(<span style="color:#66d9ef">void</span>) pal_noexcept;

	<span style="color:#75715e">/// assumed to be unsigned - but you won&#39;t have to interact with it
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">typedef</span> uint16_t pipe_sink_index_t;

	<span style="color:#75715e">// class-prototype - needed to &#34;friend&#34; the class in pipe
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010"> </span><span style="color:#a6e22e">HANDLER</span>, size_t SIZE<span style="color:#f92672">&gt;</span>
	<span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010"> </span><span style="color:#a6e22e">sink</span>;

	<span style="color:#75715e">/// pipe class
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010"> </span><span style="color:#a6e22e">HANDLER</span>, size_t SIZE<span style="color:#f92672">&gt;</span>
	<span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010"> </span><span style="color:#a6e22e">pipe</span> <span style="color:#66d9ef">final</span>
	{
		<span style="color:#66d9ef">static_assert</span> (SIZE <span style="color:#f92672">&lt;</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> (<span style="color:#ae81ff">8</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(uint16_t))), <span style="color:#e6db74">&#34;Ensure that pipe_sink_index_t can address all positions in the buffer&#34;</span>);

		<span style="color:#66d9ef">friend</span> <span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010"> </span><span style="color:#a6e22e">sink</span> <span style="color:#f92672">&lt;</span> HANDLER, SIZE <span style="color:#f92672">&gt;</span>;

		<span style="color:#75715e">// the guard for this pipe
</span><span style="color:#75715e"></span>		std<span style="color:#f92672">::</span>mutex _guard;

		<span style="color:#75715e">// write marker for the next message
</span><span style="color:#75715e"></span>		pipe_sink_index_t _write <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

		<span style="color:#75715e">// ready marker for the newest message that can be processed
</span><span style="color:#75715e"></span>		pipe_sink_index_t _ready <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

		<span style="color:#75715e">// read counter for the next message
</span><span style="color:#75715e"></span>		pipe_sink_index_t _read <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

		<span style="color:#75715e">// storage for the messages
</span><span style="color:#75715e"></span>		uint8_t _buffer[SIZE];

		<span style="color:#75715e">// pipe should never be created or destroyed outside of sink
</span><span style="color:#75715e"></span>		pipe(<span style="color:#66d9ef">void</span>) pal_noexcept {}

		<span style="color:#75715e">// pipe should never be created or destroyed outside of sink
</span><span style="color:#75715e"></span>		<span style="color:#f92672">~</span>pipe(<span style="color:#66d9ef">void</span>) pal_noexcept {}

		<span style="color:#75715e">// pipe should not be copied
</span><span style="color:#75715e"></span>		pipe(<span style="color:#66d9ef">const</span> pipe<span style="color:#f92672">&amp;</span>) <span style="color:#f92672">=</span> <span style="color:#66d9ef">delete</span>;

		<span style="color:#75715e">// pipe should not be copied
</span><span style="color:#75715e"></span>		pipe<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> pipe<span style="color:#f92672">&amp;</span>) <span style="color:#f92672">=</span> <span style="color:#66d9ef">delete</span>;

		<span style="color:#75715e">// wait until we can grab some bytes
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span>size_t LENGTH<span style="color:#f92672">&gt;</span>
		pipe_sink_index_t reserve_space(<span style="color:#66d9ef">void</span>) pal_noexcept;

		<span style="color:#75715e">// mark the bytes we previously grabbed as ready
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span>size_t LENGTH<span style="color:#f92672">&gt;</span>
		<span style="color:#66d9ef">void</span> ready_message(<span style="color:#66d9ef">const</span> pipe_sink_index_t) pal_noexcept;
	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
		<span style="color:#75715e">/// big main cool method that sends a message and returns when it&#39;s queued
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010"> </span><span style="color:#a6e22e">MESSAGE</span>, <span style="color:#66d9ef">typename</span> ...ARGS<span style="color:#f92672">&gt;</span>
		<span style="color:#66d9ef">void</span> send(ARGS<span style="color:#f92672">&amp;&amp;</span> ... args) pal_noexcept;

		<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">join</span>(<span style="color:#66d9ef">void</span>)
		{
			<span style="color:#66d9ef">while</span> (true)
			{
				std<span style="color:#f92672">::</span>lock_guard<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>mutex<span style="color:#f92672">&gt;</span> lock(_guard);

				<span style="color:#66d9ef">if</span> (_read <span style="color:#f92672">==</span> _ready)
					<span style="color:#66d9ef">return</span>;

				pal<span style="color:#f92672">::</span>pipe_sink_sleep();
			}
		}
	};


	<span style="color:#75715e">/// sink that processes messages sent along pipe
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010"> </span><span style="color:#a6e22e">HANDLER</span>, size_t SIZE<span style="color:#f92672">&gt;</span>
	<span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010"> </span><span style="color:#a6e22e">sink</span>
	{
		std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> _thread;
		HANDLER<span style="color:#f92672">*</span> _instance;

		<span style="color:#75715e">// variable to mark if we&#39;re done or not
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// ... could be an atomic bool
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">bool</span> _done;
	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>

		<span style="color:#75715e">/// creates the thread and instance before returning
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> ... ARGS<span style="color:#f92672">&gt;</span>
		sink(ARGS ... args) pal_noexcept;

		<span style="color:#75715e">/// send your messages with this!
</span><span style="color:#75715e"></span>		pal<span style="color:#f92672">::</span>pipe<span style="color:#f92672">&lt;</span>HANDLER, SIZE<span style="color:#f92672">&gt;</span> _pipe;

		HANDLER<span style="color:#f92672">*</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">-&gt;</span>(<span style="color:#66d9ef">void</span>)
		{
			<span style="color:#66d9ef">return</span> _instance;
		}

		<span style="color:#75715e">/// processes all messages before shutting down the thread and returning
</span><span style="color:#75715e"></span>		<span style="color:#75715e">/// ... don&#39;t try to send new messages while shutting down ... that might cause weird problems
</span><span style="color:#75715e"></span>		<span style="color:#f92672">~</span>sink(<span style="color:#66d9ef">void</span>) pal_noexcept
		{
			_done <span style="color:#f92672">=</span> true;
			_thread.join();
		}
	};
}

<span style="color:#75715e">#ifdef pal_cpp
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;chrono&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
pal_cpp <span style="color:#66d9ef">void</span> pal<span style="color:#f92672">::</span>pipe_sink_sleep(<span style="color:#66d9ef">void</span>) pal_noexcept
{
	std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>sleep_for(std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>nanoseconds(<span style="color:#ae81ff">830314</span>));
}

<span style="color:#75715e">#endif
</span></code></pre></div>
<h2 id="sink-constructor">Sink Constructor</h2>

<p>The <code>sink</code> constructor needs to start the processing thread, pass it some arguments, and ensure that it has created the <code>HANDLER</code> before returning.
The parameters for the instance need to be &ldquo;used&rdquo; before the stack is reclaimed - which is why the meticulous handling is required.
I was unable to find a cocktail of captures and arguments that initialised <code>HANDLER</code> with pass-by-move; so the constructor performs copy operations for the time being.<sup class="footnote-ref" id="fnref:haventTriedWithNested"><a href="#fn:haventTriedWithNested">4</a></sup>
In my design - this will only happen during startup so (should be) negligible.
It&rsquo;d be a nice thing to sus out over a coffee or a whiskey someday.</p>

<p>With the receiver constructed, the thread marks itself as done and enters the &ldquo;main&rdquo; loop that it will execute until it&rsquo;s time to conclude.
The first step of the loop is to check for either waiting data or an exit signal - and either sleep or return as appropriate.
When data is &ldquo;ready&rdquo; we can retrieve the callback - remembering that <code>_buffer + _read</code> is a pointer to the function pointer.<sup class="footnote-ref" id="fnref:threwMe"><a href="#fn:threwMe">5</a></sup>
The message <em>should</em> be allocated immediately after in memory this could be a cache alignment issue on non-traditional platforms.
The handling is performed by a function defined in the <code>send()</code> method which is described elsewhere.
The handling function leaves the <code>std::mutex</code> locked; unlocking it would lead to a need to immediately re-lock it.
At this point, the pipe is checked and reset (if possible) before execution loops and checks for an available message.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">#pragma once
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010"> </span><span style="color:#a6e22e">HANDLER</span>, size_t SIZE<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> ...ARGS<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">inline</span> pal<span style="color:#f92672">::</span>sink<span style="color:#f92672">&lt;</span>HANDLER, SIZE<span style="color:#f92672">&gt;::</span>sink(ARGS ... args) pal_noexcept :
	_instance(<span style="color:#66d9ef">nullptr</span>)
{
	<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">void</span>(<span style="color:#f92672">*</span>callback_f)(pal<span style="color:#f92672">::</span>pipe<span style="color:#f92672">&lt;</span>HANDLER, SIZE<span style="color:#f92672">&gt;&amp;</span>, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>, HANDLER<span style="color:#f92672">&amp;</span>);

	<span style="color:#66d9ef">struct</span> nested
	{
		<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#66d9ef">thread</span>(pal<span style="color:#f92672">::</span>sink<span style="color:#f92672">&lt;</span>HANDLER, SIZE<span style="color:#f92672">&gt;*</span> self, ARGS<span style="color:#f92672">&amp;&amp;</span>...args) pal_noexcept
		{
			<span style="color:#75715e">// consume the arguments and create the handler
</span><span style="color:#75715e"></span>			<span style="color:#75715e">// ... doing it in the heap to avoid problems with really-big queue sizes
</span><span style="color:#75715e"></span>			self<span style="color:#f92672">-&gt;</span>_instance <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HANDLER(args...);
			HANDLER<span style="color:#f92672">&amp;</span> handler <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(self<span style="color:#f92672">-&gt;</span>_instance);

			<span style="color:#75715e">// okay - signal to the constructor that we&#39;re done and he can tear-up the stack (we&#39;re not looking at the args anymore)
</span><span style="color:#75715e"></span>			self<span style="color:#f92672">-&gt;</span>_done <span style="color:#f92672">=</span> false;

			<span style="color:#75715e">// we&#39;ll explicitly break from this loop
</span><span style="color:#75715e"></span>			self<span style="color:#f92672">-&gt;</span>_pipe._guard.lock();
			<span style="color:#66d9ef">while</span> (true)
			{
				<span style="color:#75715e">// wait for some data to be in the pipe
</span><span style="color:#75715e"></span>				<span style="color:#66d9ef">while</span> (self<span style="color:#f92672">-&gt;</span>_pipe._read <span style="color:#f92672">==</span> self<span style="color:#f92672">-&gt;</span>_pipe._ready)
				{
					<span style="color:#75715e">// unlock before sleeping or returning
</span><span style="color:#75715e"></span>					self<span style="color:#f92672">-&gt;</span>_pipe._guard.unlock();

					<span style="color:#66d9ef">if</span> (self<span style="color:#f92672">-&gt;</span>_done)
					{
						<span style="color:#66d9ef">delete</span> self<span style="color:#f92672">-&gt;</span>_instance;
						<span style="color:#66d9ef">return</span>;
					}

					<span style="color:#75715e">// sleep for a tick and see if the pipe is refilled
</span><span style="color:#75715e"></span>					pal<span style="color:#f92672">::</span>pipe_sink_sleep();
					self<span style="color:#f92672">-&gt;</span>_pipe._guard.lock();
				}

				<span style="color:#75715e">// unlock before processing a message
</span><span style="color:#75715e"></span>				self<span style="color:#f92672">-&gt;</span>_pipe._guard.unlock();

				<span style="color:#75715e">// the &#34;head&#34; is a function pointer which we can reinterpret_cast like this
</span><span style="color:#75715e"></span>				<span style="color:#66d9ef">auto</span> callback <span style="color:#f92672">=</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>callback_f<span style="color:#f92672">*&gt;</span>(self<span style="color:#f92672">-&gt;</span>_pipe._buffer <span style="color:#f92672">+</span> self<span style="color:#f92672">-&gt;</span>_pipe._read);

				<span style="color:#75715e">// the second parameter is the address which starts after the first
</span><span style="color:#75715e"></span>				<span style="color:#66d9ef">auto</span> content <span style="color:#f92672">=</span> callback <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;

				<span style="color:#75715e">// just call it like this
</span><span style="color:#75715e"></span>				(<span style="color:#f92672">*</span>callback)(self<span style="color:#f92672">-&gt;</span>_pipe, content, handler);

				<span style="color:#75715e">// ... which leaves the mutex locked and ready to ...
</span><span style="color:#75715e"></span>
				<span style="color:#75715e">// reset if appropriate
</span><span style="color:#75715e"></span>				<span style="color:#66d9ef">if</span> (self<span style="color:#f92672">-&gt;</span>_pipe._read <span style="color:#f92672">==</span> self<span style="color:#f92672">-&gt;</span>_pipe._ready <span style="color:#f92672">&amp;&amp;</span> self<span style="color:#f92672">-&gt;</span>_pipe._ready <span style="color:#f92672">==</span> self<span style="color:#f92672">-&gt;</span>_pipe._write)
					self<span style="color:#f92672">-&gt;</span>_pipe._read <span style="color:#f92672">=</span> self<span style="color:#f92672">-&gt;</span>_pipe._ready <span style="color:#f92672">=</span> self<span style="color:#f92672">-&gt;</span>_pipe._write <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
			}

		}
	};

	<span style="color:#75715e">// flag that the thread isn&#39;t running
</span><span style="color:#75715e"></span>	_done <span style="color:#f92672">=</span> true;

	<span style="color:#75715e">// launch our thread (then wait for it to finish startup)
</span><span style="color:#75715e"></span>	_thread <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span>(nested<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span>, <span style="color:#66d9ef">this</span>, args...);

	<span style="color:#75715e">// wait for the thread to start up
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// ... because we don&#39;t want to tear down our ARGS until the thread has consumed them
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">while</span> (_done)
	{
		pal<span style="color:#f92672">::</span>pipe_sink_sleep();
	}
}
</code></pre></div>
<h2 id="send-message">Send Message</h2>

<p>When a message is sent, it needs some code tailored to the <code>MESSAGE</code> class that forms the message data.
The conventional wisdom is to use a <code>virtual</code> method; however, this left a problem of needing to retrieve a pointer to an inherited instance.
I chose to use a nested function (a static function in a nested class) which will be redefined for every invocation to match the <code>MESSAGE</code> class.<sup class="footnote-ref" id="fnref:asWouldANestedVirtualClass"><a href="#fn:asWouldANestedVirtualClass">6</a></sup>
Sending messages is complicated by the fact that the associated reading code needs to work without knowing what it&rsquo;s looking at.
To work around this, function pointers are used instead of<code>virtual</code> classes<sup class="footnote-ref" id="fnref:whyNotVirtual"><a href="#fn:whyNotVirtual">7</a></sup> and these are declared as static members of a nested class to avoid confusion.
The nested function itself simply invokes an unknown static method (with the passed <code>HANDLER</code>) before explicitly destroying the message object and advancing the markers.
The <code>std::mutex</code> is left locked - which the <code>sink</code> worker thread expects.</p>

<p>Before a message can be written, space must be reserved for it and the callback function; the writer-thread simply waits for there to be enough available space.
Once space is ready, the nested function pointer is written, the message itself is instantiated in-place before the data itself is marked as &ldquo;ready&rdquo; for the sink to process.
The last step involves &ldquo;waiting&rdquo; for any preceding messages to finish up, consider the following chronological sequence</p>

<ol>
<li>Message A (in writer-thread X) reserves space at the head of the pipe and begins writing</li>
<li>Message B (in writer-thread Y) reserves space after A and begins writing itself</li>
<li>Message B finished, but, must wait to move the <code>_ready</code> counter <em>up</em> until Message A is done</li>
</ol>

<p>Once the <code>_ready</code> counter has been moved up, the message has been sent and the writer-thread returns as it&rsquo;s done with it.
Sleepy-waits are again used here; it is the least attractive solution as there are obvious scenarios where the whole thing will hang.
Overall - it feels like the area of the class that would benefit the most from the use of <code>std::condition_variable</code> objects.</p>

<pre><code>#pragma once

template&lt;class HANDLER, size_t SIZE&gt;
template&lt;class MESSAGE, typename ... ARGS&gt;
void pal::pipe&lt;HANDLER, SIZE&gt;::send(ARGS&amp;&amp; ... args) pal_noexcept
{
	typedef void(*callback_f)(pal::pipe&lt;HANDLER, SIZE&gt;&amp;, void*, HANDLER&amp;);
	typedef void(*function_f)(pal::pipe&lt;HANDLER, SIZE&gt;*, MESSAGE*, HANDLER&amp;);

	enum size : size_t
	{
		payload = sizeof(function_f) + sizeof(MESSAGE),
	};

	// declare an olde-school static function
	struct nested
	{
		static void function(pal::pipe&lt;HANDLER, SIZE&gt;* pipe, MESSAGE* message, HANDLER&amp; data)
		{
			// run the payload's method
			MESSAGE::apply(data, message);

			// delete the event
			message-&gt;~MESSAGE();

			// ... clean it up ...

			// lock the mutex (and leave it so)
			pipe-&gt;_guard.lock();

			// advance the read marker
			pipe-&gt;_read += size::payload;
		}

	};

	// reserve space for the message
	const auto start = reserve_space&lt;size::payload&gt;();
	static_assert(size::payload &lt;= SIZE, &quot;SAN ; messages must be able to fully fit into buffer&quot;);
	static_assert(sizeof(function_f) == sizeof(callback_f), &quot;SAN ; function pointers should be the same size&quot;);

	// assign the function
	function_f* pointer = reinterpret_cast&lt;function_f*&gt;(_buffer + start);
	*pointer = nested::function;

	// create the message
	void* content = pointer + 1;
	new (content)MESSAGE(args...);

	// ready the message
	ready_message&lt;size::payload&gt;(start);
}

template&lt;class HANDLER, size_t SIZE&gt;
template&lt;size_t LENGTH&gt;
pal::pipe_sink_index_t pal::pipe&lt;HANDLER, SIZE&gt;::reserve_space(void) pal_noexcept
{
	// lock the pipe and wait for available space
	_guard.lock();
	while ((SIZE - _write) &lt; LENGTH)
	{
		// unlock, wait, relock
		_guard.unlock();
		pal::pipe_sink_sleep();
		_guard.lock();
	}

	// record the space and mark it as used
	const auto start = _write;
	_write += LENGTH;

	// we have a result
	_guard.unlock();
	return start;
}

template&lt;class HANDLER, size_t SIZE&gt;
template&lt;size_t LENGTH&gt;
void pal::pipe&lt;HANDLER, SIZE&gt;::ready_message(const pal::pipe_sink_index_t start) pal_noexcept
{
	// lock the pipe and wait for everyone before us to be ready
	_guard.lock();
	while (_ready != start)
	{
		// unlock, wait, relock
		_guard.unlock();
		pal::pipe_sink_sleep();
		_guard.lock();
	}

	// advance and unlock
	_ready += LENGTH;
	_guard.unlock();
}
</code></pre>

<h2 id="thoughts">Thoughts</h2>

<p>The implementation demonstrates some subtle characteristics and shortcomings.
Hopefully, the characteristics foster <em>good</em> development practices while providing an efficient implementation of the desired functionality.
Ideally, the shortcomings could be corrected without changing the API.</p>

<h3 id="lack-of-error-paths">Lack of Error Paths</h3>

<blockquote>
<p>&ldquo;Simplicity is prerequisite for reliability.&rdquo;</p>
</blockquote>

<p>Error handling is a <a href="https://en.oxforddictionaries.com/definition/bugbear">bugbear</a> for programmers since, by its nature, it involves the software following unanticipated logic.
Fundamentally, this is usually caused by;</p>

<ul>
<li>inputs from an upper layer outside of the expected ranges</li>
<li>outputs from a lower layer that defy expectations</li>
</ul>

<p>Since this system functions as a &ldquo;pure&rdquo; and opaque IoC - it <em>should</em> blindly pass whatever data it is given along to client code as instructed.
Most sort of errors would either be detected at compile-time or, would be outside the realm of what this software could be expected to test.
Meaningful logic is delegated to client code, the software shouldn&rsquo;t be able to &ldquo;err&rdquo; without exotic<sup class="footnote-ref" id="fnref:prematureThreadTermination"><a href="#fn:prematureThreadTermination">8</a></sup> scenarios.
The obvious contradiction to this is the fact that if the processing of a message sends a message, then the system will lockup.
Given the fact that it&rsquo;s a stated limitation, error checking for it seems as meaningful as checks for abnormal thread termination.</p>

<h3 id="templates-and-allocation">Templates and Allocation</h3>

<p>The use of templates trades (usually irrelevant)<sup class="footnote-ref" id="fnref:demoScene"><a href="#fn:demoScene">9</a></sup> compiled footprint size for a nimble framework to write a sort of parallel messaging system with.
In effect, the system doesn&rsquo;t care what classes are used for messages and what&rsquo;s used for the handler at the end - as long as compatible calls can be made it should &ldquo;just work.&rdquo;
Since the messages are allocated with in-place allocation, they should be no more complex than copying the parameters.
There&rsquo;s a caveat in all this - compilers don&rsquo;t always behave themselves and the <em>rushed</em> nature of this development means that the software hasn&rsquo;t been evaluated on a large number of systems.
Going forward - I&rsquo;d like to post this source-code publicly and assess it, and other tools, with something like <a href="https://travis-ci.org/">TravisCI</a> and <a href="https://www.sonarqube.org/">SonarQube</a> across a variety of platforms.
The time required to get to grips with a new CI tool and transplant my build configuration is the only real barrier here.</p>

<h3 id="pass-by-rvalue-reference">Pass by RValue Reference</h3>

<p>One of the more interesting C++11 features was the option to pass by &ldquo;rvalue reference&rdquo; which (presumably) reduces the overhead in function calls.
Between this and the variadic templates (also introduced in C++11), the <code>send()</code> method can be almost-as-good-as-by-hand without sacrificing the cohesion of a sealed class.
I was (frustratingly) unable to find a cocktail of closures and capture symbols that would allow the <code>HANDLER</code> to be constructed in this manner.
With more time, it would be nice to sit with a coffee and sus that out.</p>

<h3 id="true-circular-pipe">True Circular Pipe</h3>

<p>The <code>pipe</code> is not circular; in a scenario when the queue does not have enough space a writer-thread will wait until it can fit the whole message into the queue.
Implementing a true-circular buffer would (potentially) reduce the likelihood (frequency) of writer-threads needing to wait for space to be available.
This wouldn&rsquo;t be a magic bullet, however - with numerous small messages, it&rsquo;s likely that a single large message could be blocked indefinitely.</p>

<p><a href="https://github.com/incrediblejr/ijcringbuffer">Since posting this, I&rsquo;ve been made aware of a (non-magical) ring-buffer.</a></p>

<h3 id="non-sleepy-wait-conditional-variables-priority-correction">Non-Sleepy Wait / Conditional Variables / Priority Correction</h3>

<p>The use of &ldquo;sleepy-wait&rdquo; to synchronize is crude and should be avoided.
The mechanism results in threads either sleeping too long - ignoring perfectly usable data or sleeping to shortly - occupying the CPU by pestering it with &ldquo;iz ready now?&rdquo; checks.
The standard conditional variable<sup class="footnote-ref" id="fnref:conditionalVariable"><a href="#fn:conditionalVariable">10</a></sup> approach would allow threads to &ldquo;suspend&rdquo; until something to change.
Both approaches (however) suffer from a distortion of thread priority - a lower priority thread could easily wait for a higher priority one.
The sleepy-wait was chosen due to its simplicity, however,  for the purpose of this article.</p>

<h3 id="cache-alignment">Cache Alignment</h3>

<p>Cache alignment is a &ldquo;hot topic&rdquo; in performance optimisation - but somewhat irrelevant here.
When data is used by the CPU it must be moved from main memory into the CPU&rsquo;s cache, generally in 64 byte<sup class="footnote-ref" id="fnref:gcCacheSize"><a href="#fn:gcCacheSize">11</a></sup> <sup class="footnote-ref" id="fnref:soCacheSize"><a href="#fn:soCacheSize">12</a></sup> <sup class="footnote-ref" id="fnref:dlCacheSize"><a href="#fn:dlCacheSize">13</a></sup> &ldquo;lines&rdquo; which are pulled from main memory, into the cache, all at once.
By aligning data structures so that they are spread across as few CPU cache lines as possible,<sup class="footnote-ref" id="fnref:byStartingOnACacheLine"><a href="#fn:byStartingOnACacheLine">14</a></sup> the likelihood of a cache miss is decreased and the CPU is less likely to stall.
This poses an odd challenge, since, the <code>static_assert</code> checks related to message size would become more complicated.</p>

<p>Data written to the queue will have a performance characteristic unknown to the author.
Data is read from the queue, however, will be carried out sequentially.
Since data is &ldquo;always&rdquo; used - the problem of wasted cycles pulling cache lines into the CPU seems (largely) irrelevant.
Any cache line pulled in to hold the tail of one message will, likely, contain data for the next message - and when starting a message, it&rsquo;s head will likely have been cached by the message in front of it.</p>

<h3 id="applicability">Applicability</h3>

<p>This was written for an OpenGL renderer, past iterations of this worked well enough that I could submit GL calls faster than the system could process them.
During development, I read a passage about a parallel renderer<sup class="footnote-ref" id="fnref:rtr2-ch10-5-1"><a href="#fn:rtr2-ch10-5-1">15</a></sup> that would benefit from being able to split jobs amongst various threads and relying upon the <code>HANDLER</code> to merge them at the end.
This scenario would likely involve multiple instances of <code>pipe-sink</code> talking to each other, but, seems interesting to explore as I go on with this.</p>

<p>Overall; my goal was a convenient type class to help parallelize rendering work - I feel that this is a success.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;util/pal.hpp&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;gtest/gtest.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">struct</span> accumulator
{
	<span style="color:#66d9ef">int</span> _val;
	<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> _prefix;
	accumulator(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> prefix, <span style="color:#66d9ef">int</span> start) pal_noexcept :
	_prefix(prefix),
		_val(start)
	{
	}

	<span style="color:#f92672">~</span>accumulator(<span style="color:#66d9ef">void</span>)
	{
	}

};

TEST(pipe_sink, test_creation)
{
	pal<span style="color:#f92672">::</span>sink<span style="color:#f92672">&lt;</span>accumulator, <span style="color:#ae81ff">128</span><span style="color:#f92672">&gt;</span> test_sink(<span style="color:#e6db74">&#34;test_sink&#34;</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);


	ASSERT_EQ(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, test_sink<span style="color:#f92672">-&gt;</span>_val);
}

TEST(pipe_sink, test_sending)
{
	pal<span style="color:#f92672">::</span>sink<span style="color:#f92672">&lt;</span>accumulator, <span style="color:#ae81ff">128</span><span style="color:#f92672">&gt;</span> test_send(<span style="color:#e6db74">&#34;test_send&#34;</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);

	<span style="color:#66d9ef">struct</span> addone
	{
		<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">double</span> sentinel <span style="color:#f92672">=</span> <span style="color:#ae81ff">3.14</span>;
		<span style="color:#66d9ef">int</span> _v;
		addone(<span style="color:#66d9ef">int</span> v) <span style="color:#f92672">:</span> _v(v)
		{
		}

		<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> apply(accumulator<span style="color:#f92672">&amp;</span> them, addone<span style="color:#f92672">*</span> self)
		{
			assert(<span style="color:#ae81ff">3.14</span> <span style="color:#f92672">==</span> self<span style="color:#f92672">-&gt;</span>sentinel);

			them._val <span style="color:#f92672">+=</span> self<span style="color:#f92672">-&gt;</span>_v;
		}

		<span style="color:#f92672">~</span>addone(<span style="color:#66d9ef">void</span>)
		{
			assert(<span style="color:#ae81ff">3.14</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>sentinel);

		}
	};

	test_send._pipe.send<span style="color:#f92672">&lt;</span>addone<span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">1</span>);

	test_send._pipe.join();
	ASSERT_EQ(<span style="color:#ae81ff">0</span>, test_send<span style="color:#f92672">-&gt;</span>_val);

	test_send._pipe.send<span style="color:#f92672">&lt;</span>addone<span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">2</span>);
	test_send._pipe.send<span style="color:#f92672">&lt;</span>addone<span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">3</span>);

	test_send._pipe.join();
	ASSERT_EQ(<span style="color:#ae81ff">5</span>, test_send<span style="color:#f92672">-&gt;</span>_val);

	<span style="color:#66d9ef">struct</span> checkis
	{
		<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> _value;
		checkis(<span style="color:#66d9ef">int</span> value) <span style="color:#f92672">:</span> _value(value)
		{
		}

		<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> apply(accumulator<span style="color:#f92672">&amp;</span> them, checkis<span style="color:#f92672">*</span> self)
		{
			ASSERT_EQ(self<span style="color:#f92672">-&gt;</span>_value, them._val) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;FAILED</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">e=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> self<span style="color:#f92672">-&gt;</span>_value <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">a=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> them._val <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
		}
	};
	test_send._pipe.send<span style="color:#f92672">&lt;</span>checkis<span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">5</span>);
	test_send._pipe.send<span style="color:#f92672">&lt;</span>addone<span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">4</span>);
	test_send._pipe.send<span style="color:#f92672">&lt;</span>checkis<span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">9</span>);

}
</code></pre></div><div class="footnotes">

<hr />

<ol>
<li id="fn:4aEngine"><a href="https://en.wikipedia.org/wiki/4A_Engine">https://en.wikipedia.org/wiki/4A_Engine</a>
 <a class="footnote-return" href="#fnref:4aEngine"><sup>[return]</sup></a></li>
<li id="fn:AppleOpenGLThreads"><a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/OpenGL-MacProgGuide/opengl_threading/opengl_threading.html">https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/OpenGL-MacProgGuide/opengl_threading/opengl_threading.html</a>
 <a class="footnote-return" href="#fnref:AppleOpenGLThreads"><sup>[return]</sup></a></li>
<li id="fn:GLFWReentrancy"><a href="http://www.glfw.org/docs/latest/intro_guide.html#reentrancy">http://www.glfw.org/docs/latest/intro_guide.html#reentrancy</a>
 <a class="footnote-return" href="#fnref:GLFWReentrancy"><sup>[return]</sup></a></li>
<li id="fn:haventTriedWithNested">I haven&rsquo;t tried this since switching to a nested class rather than a lambda
 <a class="footnote-return" href="#fnref:haventTriedWithNested"><sup>[return]</sup></a></li>
<li id="fn:threwMe">This threw me and was hard to debug
 <a class="footnote-return" href="#fnref:threwMe"><sup>[return]</sup></a></li>
<li id="fn:asWouldANestedVirtualClass">As would a nested subclass. No savings there.
 <a class="footnote-return" href="#fnref:asWouldANestedVirtualClass"><sup>[return]</sup></a></li>
<li id="fn:whyNotVirtual">Virtual classes would have an unknown offset. While this could
 <a class="footnote-return" href="#fnref:whyNotVirtual"><sup>[return]</sup></a></li>
<li id="fn:prematureThreadTermination">Threads can be closed by the system or user code unexpectedly - that would kill it
 <a class="footnote-return" href="#fnref:prematureThreadTermination"><sup>[return]</sup></a></li>
<li id="fn:demoScene">Competitive programming &ldquo;DemoScene&rdquo; uses a small code-footprint to demonstrate highly detailed graphics scenes. Since templates are generally inlaid, I would expect that they have a firm impact on code-footprint.
 <a class="footnote-return" href="#fnref:demoScene"><sup>[return]</sup></a></li>
<li id="fn:conditionalVariable"><a href="https://en.wikipedia.org/wiki/Monitor_(synchronization)#Condition_variables_2">https://en.wikipedia.org/wiki/Monitor_(synchronization)#Condition_variables_2</a>
 <a class="footnote-return" href="#fnref:conditionalVariable"><sup>[return]</sup></a></li>
<li id="fn:gcCacheSize"><a href="https://course.ccs.neu.edu/com3200/">https://course.ccs.neu.edu/com3200/</a>
 <a class="footnote-return" href="#fnref:gcCacheSize"><sup>[return]</sup></a></li>
<li id="fn:soCacheSize"><a href="https://stackoverflow.com/questions/7281699/aligning-to-cache-line-and-knowing-the-cache-line-size#7281770">https://stackoverflow.com/questions/7281699/aligning-to-cache-line-and-knowing-the-cache-line-size#7281770</a>
 <a class="footnote-return" href="#fnref:soCacheSize"><sup>[return]</sup></a></li>
<li id="fn:dlCacheSize"><a href="http://lemire.me/blog/2012/05/31/data-alignment-for-speed-myth-or-reality/">http://lemire.me/blog/2012/05/31/data-alignment-for-speed-myth-or-reality/</a>
 <a class="footnote-return" href="#fnref:dlCacheSize"><sup>[return]</sup></a></li>
<li id="fn:byStartingOnACacheLine">Generally, this is done by allocating mor space than needed and ignoring the extra space at the start of the allocated block.
 <a class="footnote-return" href="#fnref:byStartingOnACacheLine"><sup>[return]</sup></a></li>
<li id="fn:rtr2-ch10-5-1">Akenine-Moller and Haines ; Real-Time Rendering Second Edition, Chapter 10.5.1
 <a class="footnote-return" href="#fnref:rtr2-ch10-5-1"><sup>[return]</sup></a></li>
</ol>
</div>
</div>
				
				<footer class="entry__footer">
					
<div class="entry__tags">
			<a class="entry__tag btn" href="/tags/multi-threading/">multi-threading</a>
			<a class="entry__tag btn" href="/tags/c&#43;&#43;/">C&#43;&#43;</a>
</div>
					
<div class="entry__share share">
	<a class="share__link btn" title="Share on Facebook" href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fpeterlavalle.github.io%2fpost%2fpal-pipe-sink%2f" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Share on Facebook', 'width=800,height=600,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Facebook" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M330 512V322h64l9-74h-73v-47c0-22 6-36 37-36h39V99c-7-1-30-3-57-3-57 0-95 34-95 98v54h-64v74h64v190z"/></svg>
	</a>
	<a class="share__link btn" title="Share on Twitter" href="https://twitter.com/intent/tweet/?url=https%3a%2f%2fpeterlavalle.github.io%2fpost%2fpal-pipe-sink%2f&amp;text=Pipe%20Sink" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Share on Twitter', 'width=800,height=450,resizable=yes,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Twitter" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M437 152a72 72 0 0 1-40 12 72 72 0 0 0 32-40 72 72 0 0 1-45 17 72 72 0 0 0-122 65 200 200 0 0 1-145-74 72 72 0 0 0 22 94 72 72 0 0 1-32-7 72 72 0 0 0 56 69 72 72 0 0 1-32 1 72 72 0 0 0 67 50 200 200 0 0 1-105 29 200 200 0 0 0 309-179 200 200 0 0 0 35-37"/></svg>
	</a>
	<a class="share__link btn" title="Share on Reddit" href="https://www.reddit.com/submit?url=https%3a%2f%2fpeterlavalle.github.io%2fpost%2fpal-pipe-sink%2f&amp;title=Pipe%20Sink" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Share on Reddit', 'width=832,height=624,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Reddit" role="img" width="32" height="32" viewBox="0 0 512 512"><path fill-rule="evenodd" d="M375 146a32 32 0 1 0-29-46l-65-13c-5-1-9 2-10 6l-22 97c-45 1-85 15-113 36a42 42 0 1 0-45 69l-1 12c0 65 74 117 166 117s166-52 166-117l-1-11a42 42 0 1 0-44-69c-28-21-67-35-111-37l19-86 58 13a32 32 0 0 0 32 29zM190 353c2-1 4 0 5 1 15 11 38 18 61 18s46-6 61-18a7 7 0 0 1 8 10c-18 14-44 21-69 21-25-1-51-7-69-21a6 6 0 0 1 3-11zm23-44a31 31 0 1 1-44-44 31 31 0 0 1 44 44zm130 0a31 31 0 1 0-44-44 31 31 0 0 0 44 44z"/></svg>
	</a>
	<a class="share__link btn" title="Share on Telegram" href="https://t.me/share/url?url=https%3a%2f%2fpeterlavalle.github.io%2fpost%2fpal-pipe-sink%2f&amp;title=Pipe%20Sink" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Share on Telegram', 'width=800,height=600,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Telegram" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M199 404c-11 0-10-4-13-14l-32-105 245-144"/><path d="M199 404c7 0 11-4 16-8l45-43-56-34"/><path d="M204 319l135 99c14 9 26 4 30-14l55-258c5-22-9-32-24-25L79 245c-21 8-21 21-4 26l83 26 190-121c9-5 17-3 11 4"/></svg>
	</a>
	<a class="share__link btn" title="Share on LinkedIn" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fpeterlavalle.github.io%2fpost%2fpal-pipe-sink%2f&title=Pipe%20Sink" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Share on LinkedIn', 'width=640,height=480,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="LinkedIn" role="img" width="32" height="32" viewBox="0 0 512 512"><circle cx="142" cy="138" r="37"/><path stroke-width="66" d="M244 194v198M142 194v198"/><path d="M276 282c0-20 13-40 36-40 24 0 33 18 33 45v105h66V279c0-61-32-89-76-89-34 0-51 19-59 32"/></svg>
	</a>
	<a class="share__link btn" title="Share on VK" href="https://vk.com/share.php?url=https%3a%2f%2fpeterlavalle.github.io%2fpost%2fpal-pipe-sink%2f" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Share on VK', 'width=640,height=480,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="VK" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M274 363c5-1 14-3 14-15 0 0-1-30 13-34s32 29 51 42c14 9 25 8 25 8l51-1s26-2 14-23c-1-2-9-15-39-42-31-30-26-25 11-76 23-31 33-50 30-57-4-7-20-6-20-6h-57c-6 0-9 1-12 6 0 0-9 25-21 45-25 43-35 45-40 42-9-5-7-24-7-37 0-45 7-61-13-65-13-2-59-4-73 3-7 4-11 11-8 12 3 0 12 1 17 7 8 13 9 75-2 81-15 11-53-62-62-86-2-6-5-7-12-9H79c-6 0-15 1-11 13 27 56 83 193 184 192z"/></svg>
	</a>
	<a class="share__link btn" title="Save to Pocket" href="https://getpocket.com/edit?url=https%3a%2f%2fpeterlavalle.github.io%2fpost%2fpal-pipe-sink%2f&amp;title=Pipe%20Sink" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Save to Pocket', 'width=480,height=320,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Pocket" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M388.8 88.9H123.2A47.4 47.4 0 0 0 76 136.5v131.9c0 2.4.2 4.8.5 7.2a101.8 101.8 0 0 0-.5 10.6c0 75.6 80.6 137 180 137s180-61.4 180-137c0-3.6-.2-7.1-.5-10.6.3-2.4.5-4.8.5-7.2v-132A47.4 47.4 0 0 0 388.8 89zm-22.4 132.6l-93 93c-4.7 4.6-11 7-17.1 7a23.8 23.8 0 0 1-17.7-7l-93-93a24 24 0 0 1 33.8-33.8l76.6 76.5 76.6-76.5a24 24 0 0 1 33.8 33.8z"/></svg>
	</a>
</div>
				</footer>
				
			<div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "peterlavalle" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
			</article>
		</div>
	</main>
	
<div class="authorbox block">
	<div class="author">
		<figure class="author__avatar">
			<img class="author__img" alt="Peter LaValle avatar" src="https://avatars2.githubusercontent.com/u/956075?v=3&amp;s=460" height="90" width="90">
		</figure>
		<div class="author__body">
			<div class="author__name">
				Peter LaValle
			</div>
			<div class="author__bio">		Any links probably include affiliate ids for that sweet sweet kickback - and some programs require that I tell you.
		The contents of this blog are likely unrelated - as they include games, paints, and build tools.
	</div>
		</div>
	</div>
</div>
	



	

	</div>
	<footer class="footer">
<div class="footer__social social">
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="mailto:peter.lavalle@gmail.com">
			<svg class="social__icon" aria-label="Email" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M299 268l124 106c-4 4-10 7-17 7H106c-7 0-13-3-17-7l124-106 43 38 43-38zm-43 13L89 138c4-4 10-7 17-7h300c7 0 13 3 17 7L256 281zm54-23l121-105v208L310 258zM81 153l121 105L81 361V153z"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://twitter.com/g_pechorin">
			<svg class="social__icon" aria-label="Twitter" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M437 152a72 72 0 0 1-40 12 72 72 0 0 0 32-40 72 72 0 0 1-45 17 72 72 0 0 0-122 65 200 200 0 0 1-145-74 72 72 0 0 0 22 94 72 72 0 0 1-32-7 72 72 0 0 0 56 69 72 72 0 0 1-32 1 72 72 0 0 0 67 50 200 200 0 0 1-105 29 200 200 0 0 0 309-179 200 200 0 0 0 35-37"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://www.instagram.com/gpechorin">
			<svg class="social__icon" aria-label="Instagram" role="img" width="32" height="32" viewBox="0 0 512 512"><g fill="none" stroke-width="29"><rect height="296" rx="78" width="296" x="108" y="108"/><circle cx="256" cy="256" r="69"/></g><circle cx="343" cy="169" r="19"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://linkedin.com/in/plavalle">
			<svg class="social__icon" aria-label="LinkedIn" role="img" width="32" height="32" viewBox="0 0 512 512"><circle cx="142" cy="138" r="37"/><path stroke-width="66" d="M244 194v198M142 194v198"/><path d="M276 282c0-20 13-40 36-40 24 0 33 18 33 45v105h66V279c0-61-32-89-76-89-34 0-51 19-59 32"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://github.com/peterlavalle">
			<svg class="social__icon" aria-label="Github" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M335 499c14 0 12 17 12 17H165s-2-17 12-17c13 0 16-6 16-12l-1-50c-71 16-86-28-86-28-12-30-28-37-28-37-24-16 1-16 1-16 26 2 40 26 40 26 22 39 59 28 74 22 2-17 9-28 16-35-57-6-116-28-116-126 0-28 10-51 26-69-3-6-11-32 3-67 0 0 21-7 70 26 42-12 86-12 128 0 49-33 70-26 70-26 14 35 6 61 3 67 16 18 26 41 26 69 0 98-60 120-117 126 10 8 18 24 18 48l-1 70c0 6 3 12 16 12z"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://gitlab.com/g-pechorin">
			<svg class="social__icon" aria-label="Gitlab" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M450 282l-22-67-43-133c-2-7-12-7-14 0l-43.3 133H184.3L141 82c-2-7-12-7-14 0L84 215l-22 67c-2 6 0 13 6 16l188 137 188-137c6-3 8-10 6-16z"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://stackoverflow.com/users/482808">
			<svg class="social__icon" aria-label="Stack Overflow" role="img" width="32" height="32" viewBox="0 0 512 512"><g stroke-width="30"><path fill="none" d="M125 297v105h241V297"/><path d="M170 341h150m-144-68l148 31M199 204l136 64m-95-129l115 97M293 89l90 120"/></g></svg>
		</a>
</div>
	<div class="footer__copyright"> 2024 Peter&#39;s Notebook. <span class="footer__copyright-credits">Powered by <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/vimux/binario" rel="nofollow noopener" target="_blank">Binario</a> theme.</span></div>
</footer>
<script async src="//www.instagram.com/embed.js"></script>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<script src="/js/menu.js"></script>
</body>
</html>